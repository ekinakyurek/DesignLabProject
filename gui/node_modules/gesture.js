var ads1x15 = require('node-ads1x15');
var regression = require('./regression')

function gesture(chip, channel, pga, sps, channels) {

        this.chip = chip;
        this.channel = channel
        this.pga = pga;
        this.sps = sps;
        this.gestureArray = [];
        this.channels = channels;
        this.current_channel_index = 0;
        this.adc = new ads1x15(chip);
       
        this.waiting_for_click = false;
        this.waiting_for_click_multiple = [];
        this.click_point = 0.0;
        this.click_point_multiple = [];
        this.input_length = 5;
        this.last_average = [];
};

gesture.prototype.startReading = function(event){

    this.event = event
    self = this
    

    if(!this.adc.busy){
	

        this.adc.startContinuousConversion(this.channel, this.pga, this.sps, function(err,data) {
            if(err)
            {
                //logging / troubleshooting code goes here...
                throw err;
            }
        delay = 1000 / self.sps;
	    delay = 0.2
	    //console.log(delay)
            //

	    setInterval(self.readinglopp.bind(self), delay)
            // if you made it here, then the data object contains your reading!

            // any other data processing code goes here...
        })
    }
}


gesture.prototype.startMultiChannelReading = function(event,channels){

    self = this
    self.event = event;
    self.channels = channels;
    self.event.emit = event.send;
    
	for (var i=0; i<self.channels.length; i++ ){
		self.gestureArray.push([]);
		self.waiting_for_click_multiple.push(false);
		self.click_point_multiple.push(0.0);
		self.last_average.push(0.0);
    }

    //delay = 1 + 1000/self.sps;
    delay = 0.1
    setInterval(self.readinglopp2.bind(self),delay);
}

gesture.prototype.handleWithClickEvent = function(channel, clickPoint){
    self = this;
    console.log(channel + " :first average: " + clickPoint + ": last average" +  self.last_average[channel])
}


gesture.prototype.readinglopp2 = function(){
    self = this
    if(!self.adc.busy){

	self.current_channel_index = self.current_channel_index+1;
	self.current_channel_index = self.current_channel_index % self.channels.length;
	var current = self.current_channel_index;
	
	self.adc.readADCSingleEnded(self.channels[self.current_channel_index], self.pga, self.sps, function(err, data) {
	    if(err)
	    {
		//logging / troubleshooting code goes here...
		throw err;
	    }
	    data /= 3200
	    data = data<0 ? 0:data
	    // if you made it here, then the data object contains your reading!
	    // console.log("device:" + current + ":" + data);
	    self.gestureArray[current].push([self.gestureArray[current].length, data])

	    var gesture_array = self.gestureArray[current]
     
	    if(gesture_array.length%self.input_length==0){

		//var test_data = [[0,1],[1,2], [2,3], [3,4]]
		//var result = regression('linear',test_data);
		var result = regression('linear', gesture_array)
		//console.log("slope: " + result.equation[0]);
		//console.log("correlation: " + result.equation[2]);
		var average = 0;

		for(var i=0, n=gesture_array.length; i < n; i++)
		{
		   average += gesture_array[i][1];
		}
		average = average/gesture_array.length;

		self.last_average[current] = average;

		if (!self.waiting_for_click_multiple[current]){

		    if(result.equation[0] > 0.00049 && result.equation[2] > 0.97  && average > 0.1) {

			self.event.emit("swipe-up,"+ current.toString(), result.equation[0]);
		    //console.log("swipe up")
		    //console.log("slope: " + result.equation[0]);
		    //console.log("correlation: " + result.equation[2]);

		    }else if(result.equation[0] < -0.00049 && result.equation[2] < -0.97 && average > 0.1){

			self.event.emit("swipe-down,"+current.toString(), result.equation[0]);
		    //console.log("swipe down")
		    //console.log("slope: " + result.equation[0]);
		    //console.log("correlation: " + result.equation[2]);

		    }else if((result.equation[2] > 0.90 || result.equation[2]<-0.90) && (average < 0.1)){

			self.click_point_multiple[current]  = average;
			self.waiting_for_click_multiple[current] = true   
			setTimeout(function(){
			               self.waiting_for_click_multiple[current] = false;
					       self.event.emit("click-event," + current.toString() , average);}.bind(self,average, current), 600)
		    }
		}
		
		self.gestureArray[current].length = 0;
	    }
	    // any other data processing code goes here...
	});
    }
}


module.exports = gesture;
